{"ast":null,"code":"// We have made the assumption that the appointments are all in the same day\nfunction convertTimeToMinutes(time) {\n  const [hours, minutes] = time.split(\":\").map(Number);\n  return hours * 60 + minutes;\n}\nfunction determineOverlaps(appointments) {\n  let overlapsCounter = {}; // a dictionary to store each appointment id how many time, it will interact with others appointments for the same group schedule and also add it a column index\n  let timePoints = []; // an array to destructure the appointments into 2 categories: start and end which will help for having better algorithm to determine the overlaps\n  let columnIndexes = new Set(); // a set to store the column indexes that are already used and then defined the index in the group of appointments\n  let eventsInSameGroup = new Set(); // a set to store the appointments that are in the same group schedule\n  let maxColumnIndex = 0; // a variable to store the maximum column index that can be reached in the group of appointments\n\n  // Loop through the appointments and destructure them into timePoints with start and end time\n  // Also initialize overlapsCounter\n  appointments.forEach(appointment => {\n    if (!overlapsCounter[appointment.id]) {\n      overlapsCounter[appointment.id] = {\n        count: 0,\n        startTime: appointment.start,\n        startTimeConverted: convertTimeToMinutes(appointment.start),\n        duration: appointment.duration,\n        columnIndex: null\n      };\n    }\n    timePoints.push({\n      time: overlapsCounter[appointment.id].startTimeConverted,\n      type: \"start\",\n      id: appointment.id\n    });\n    timePoints.push({\n      time: overlapsCounter[appointment.id].startTimeConverted + appointment.duration,\n      type: \"end\",\n      id: appointment.id\n    });\n  });\n\n  // Sort timePoints by time, prioritizing end times over start times\n  timePoints.sort((a, b) => a.time - b.time || (a.type === \"end\" ? -1 : 1));\n\n  // Loop through the timePoints array and determine the overlaps\n  timePoints.forEach(timePoint => {\n    if (timePoint.type === \"start\") {\n      //Find the first available index column\n      let columnIndex = 0;\n      while (columnIndexes.has(columnIndex)) {\n        columnIndex++;\n      }\n      columnIndexes.add(columnIndex);\n\n      // Save the maximum column index that can be reached in the group schedule of appointments\n      maxColumnIndex = Math.max(maxColumnIndex, columnIndex);\n\n      // Save the column index for a specific appointment id\n      overlapsCounter[timePoint.id][\"columnIndex\"] = columnIndex;\n\n      // Add the appointment id to the set of appointments that are in the same group schedule\n      eventsInSameGroup.add(timePoint.id);\n    } else {\n      // Remove the appointment id from the set of appointments that are in the same group schedule\n      columnIndexes.delete(overlapsCounter[timePoint.id][\"columnIndex\"]);\n\n      // When = 0, it means that the appointment is the last one in the group of appointments, so we can save the maximum column index that can be reached in the group of appointments\n      if (columnIndexes.size === 0) {\n        eventsInSameGroup.forEach(eventId => {\n          overlapsCounter[eventId][\"overlapsCount\"] = maxColumnIndex + 1;\n        });\n        maxColumnIndex = 0;\n        eventsInSameGroup.clear();\n      }\n    }\n  });\n  return overlapsCounter;\n}\nexport default determineOverlaps;","map":{"version":3,"names":["convertTimeToMinutes","time","hours","minutes","split","map","Number","determineOverlaps","appointments","overlapsCounter","timePoints","columnIndexes","Set","eventsInSameGroup","maxColumnIndex","forEach","appointment","id","count","startTime","start","startTimeConverted","duration","columnIndex","push","type","sort","a","b","timePoint","has","add","Math","max","delete","size","eventId","clear"],"sources":["/Users/thierryvo/Coding/Planity 202312/src/AppointmentModel.js"],"sourcesContent":["// We have made the assumption that the appointments are all in the same day\nfunction convertTimeToMinutes(time) {\n  const [hours, minutes] = time.split(\":\").map(Number);\n  return hours * 60 + minutes;\n}\n\nfunction determineOverlaps(appointments) {\n  let overlapsCounter = {}; // a dictionary to store each appointment id how many time, it will interact with others appointments for the same group schedule and also add it a column index\n  let timePoints = []; // an array to destructure the appointments into 2 categories: start and end which will help for having better algorithm to determine the overlaps\n  let columnIndexes = new Set(); // a set to store the column indexes that are already used and then defined the index in the group of appointments\n  let eventsInSameGroup = new Set(); // a set to store the appointments that are in the same group schedule\n  let maxColumnIndex = 0; // a variable to store the maximum column index that can be reached in the group of appointments\n\n  // Loop through the appointments and destructure them into timePoints with start and end time\n  // Also initialize overlapsCounter\n  appointments.forEach((appointment) => {\n    if (!overlapsCounter[appointment.id]) {\n      overlapsCounter[appointment.id] = {\n        count: 0,\n        startTime: appointment.start,\n        startTimeConverted: convertTimeToMinutes(appointment.start),\n        duration: appointment.duration,\n        columnIndex: null,\n      };\n    }\n    timePoints.push({\n      time: overlapsCounter[appointment.id].startTimeConverted,\n      type: \"start\",\n      id: appointment.id,\n    });\n    timePoints.push({\n      time:\n        overlapsCounter[appointment.id].startTimeConverted +\n        appointment.duration,\n      type: \"end\",\n      id: appointment.id,\n    });\n  });\n\n  // Sort timePoints by time, prioritizing end times over start times\n  timePoints.sort((a, b) => a.time - b.time || (a.type === \"end\" ? -1 : 1));\n\n  // Loop through the timePoints array and determine the overlaps\n  timePoints.forEach((timePoint) => {\n    if (timePoint.type === \"start\") {\n      //Find the first available index column\n      let columnIndex = 0;\n      while (columnIndexes.has(columnIndex)) {\n        columnIndex++;\n      }\n      columnIndexes.add(columnIndex);\n\n      // Save the maximum column index that can be reached in the group schedule of appointments\n      maxColumnIndex = Math.max(maxColumnIndex, columnIndex);\n\n      // Save the column index for a specific appointment id\n      overlapsCounter[timePoint.id][\"columnIndex\"] = columnIndex;\n\n      // Add the appointment id to the set of appointments that are in the same group schedule\n      eventsInSameGroup.add(timePoint.id);\n    } else {\n      // Remove the appointment id from the set of appointments that are in the same group schedule\n      columnIndexes.delete(overlapsCounter[timePoint.id][\"columnIndex\"]);\n\n      // When = 0, it means that the appointment is the last one in the group of appointments, so we can save the maximum column index that can be reached in the group of appointments\n      if (columnIndexes.size === 0) {\n        eventsInSameGroup.forEach((eventId) => {\n          overlapsCounter[eventId][\"overlapsCount\"] = maxColumnIndex + 1;\n        });\n\n        maxColumnIndex = 0;\n        eventsInSameGroup.clear();\n      }\n    }\n  });\n\n  return overlapsCounter;\n}\n\nexport default determineOverlaps;\n"],"mappings":"AAAA;AACA,SAASA,oBAAoBA,CAACC,IAAI,EAAE;EAClC,MAAM,CAACC,KAAK,EAAEC,OAAO,CAAC,GAAGF,IAAI,CAACG,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,MAAM,CAAC;EACpD,OAAOJ,KAAK,GAAG,EAAE,GAAGC,OAAO;AAC7B;AAEA,SAASI,iBAAiBA,CAACC,YAAY,EAAE;EACvC,IAAIC,eAAe,GAAG,CAAC,CAAC,CAAC,CAAC;EAC1B,IAAIC,UAAU,GAAG,EAAE,CAAC,CAAC;EACrB,IAAIC,aAAa,GAAG,IAAIC,GAAG,CAAC,CAAC,CAAC,CAAC;EAC/B,IAAIC,iBAAiB,GAAG,IAAID,GAAG,CAAC,CAAC,CAAC,CAAC;EACnC,IAAIE,cAAc,GAAG,CAAC,CAAC,CAAC;;EAExB;EACA;EACAN,YAAY,CAACO,OAAO,CAAEC,WAAW,IAAK;IACpC,IAAI,CAACP,eAAe,CAACO,WAAW,CAACC,EAAE,CAAC,EAAE;MACpCR,eAAe,CAACO,WAAW,CAACC,EAAE,CAAC,GAAG;QAChCC,KAAK,EAAE,CAAC;QACRC,SAAS,EAAEH,WAAW,CAACI,KAAK;QAC5BC,kBAAkB,EAAErB,oBAAoB,CAACgB,WAAW,CAACI,KAAK,CAAC;QAC3DE,QAAQ,EAAEN,WAAW,CAACM,QAAQ;QAC9BC,WAAW,EAAE;MACf,CAAC;IACH;IACAb,UAAU,CAACc,IAAI,CAAC;MACdvB,IAAI,EAAEQ,eAAe,CAACO,WAAW,CAACC,EAAE,CAAC,CAACI,kBAAkB;MACxDI,IAAI,EAAE,OAAO;MACbR,EAAE,EAAED,WAAW,CAACC;IAClB,CAAC,CAAC;IACFP,UAAU,CAACc,IAAI,CAAC;MACdvB,IAAI,EACFQ,eAAe,CAACO,WAAW,CAACC,EAAE,CAAC,CAACI,kBAAkB,GAClDL,WAAW,CAACM,QAAQ;MACtBG,IAAI,EAAE,KAAK;MACXR,EAAE,EAAED,WAAW,CAACC;IAClB,CAAC,CAAC;EACJ,CAAC,CAAC;;EAEF;EACAP,UAAU,CAACgB,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAAC1B,IAAI,GAAG2B,CAAC,CAAC3B,IAAI,KAAK0B,CAAC,CAACF,IAAI,KAAK,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;;EAEzE;EACAf,UAAU,CAACK,OAAO,CAAEc,SAAS,IAAK;IAChC,IAAIA,SAAS,CAACJ,IAAI,KAAK,OAAO,EAAE;MAC9B;MACA,IAAIF,WAAW,GAAG,CAAC;MACnB,OAAOZ,aAAa,CAACmB,GAAG,CAACP,WAAW,CAAC,EAAE;QACrCA,WAAW,EAAE;MACf;MACAZ,aAAa,CAACoB,GAAG,CAACR,WAAW,CAAC;;MAE9B;MACAT,cAAc,GAAGkB,IAAI,CAACC,GAAG,CAACnB,cAAc,EAAES,WAAW,CAAC;;MAEtD;MACAd,eAAe,CAACoB,SAAS,CAACZ,EAAE,CAAC,CAAC,aAAa,CAAC,GAAGM,WAAW;;MAE1D;MACAV,iBAAiB,CAACkB,GAAG,CAACF,SAAS,CAACZ,EAAE,CAAC;IACrC,CAAC,MAAM;MACL;MACAN,aAAa,CAACuB,MAAM,CAACzB,eAAe,CAACoB,SAAS,CAACZ,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC;;MAElE;MACA,IAAIN,aAAa,CAACwB,IAAI,KAAK,CAAC,EAAE;QAC5BtB,iBAAiB,CAACE,OAAO,CAAEqB,OAAO,IAAK;UACrC3B,eAAe,CAAC2B,OAAO,CAAC,CAAC,eAAe,CAAC,GAAGtB,cAAc,GAAG,CAAC;QAChE,CAAC,CAAC;QAEFA,cAAc,GAAG,CAAC;QAClBD,iBAAiB,CAACwB,KAAK,CAAC,CAAC;MAC3B;IACF;EACF,CAAC,CAAC;EAEF,OAAO5B,eAAe;AACxB;AAEA,eAAeF,iBAAiB"},"metadata":{},"sourceType":"module","externalDependencies":[]}